//#########################################################
//#
//# Titre : 	Utilitaires Liste Chainee et CVS LINUX Automne 24
//#				SIF-1015 - Système d'exploitation
//#				Université du Québec à Trois-Rivières
//#
//# Auteur : 	Francois Meunier
//#	Date :		Septembre 2024
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#include <sys/stat.h>
#include <pthread.h>
#include <signal.h>


struct noeudVM* head = NULL;
struct noeudVM* queue = NULL;
int nbVM = 0;


//#######################################
//#
//# Affiche une série de retour de ligne pour "nettoyer" la console
//#
void cls(void){
	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
	}

//#######################################
//#
//# Affiche un message et quitte le programme
//#
void error(const int exitcode, const char * message){
	printf("\n-------------------------\n%s\n",message);
	exit(exitcode);
	}
	
/* Sign Extend */
uint16_t sign_extend(uint16_t x, int bit_count)
{
    if ((x >> (bit_count - 1)) & 1) {
        x |= (0xFFFF << bit_count);
    }
    return x;
}

/* Swap */
uint16_t swap16(uint16_t x)
{
    return (x << 8) | (x >> 8);
}

/* Update Flags */
void update_flags(uint16_t reg[R_COUNT], uint16_t r)
{
    if (reg[r] == 0)
    {
        reg[R_COND] = FL_ZRO;
    }
    else if (reg[r] >> 15) /* a 1 in the left-most bit indicates negative */
    {
        reg[R_COND] = FL_NEG;
    }
    else
    {
        reg[R_COND] = FL_POS;
    }
}


/* Validation of an adress generated by a program  */
int validAdress(uint16_t * memory,uint16_t  offset, struct noeudVM * ptr, char accessType)
{
	
	if(((memory+offset) > (memory+65535)) || ((memory) > (memory+offset)) )
	{  
		printf("\n Adresse invalide");
		return 0; 
	}	
    if (accessType == 'W') { // validate if in code region
			if(((memory+offset) > (memory+ptr->VM.offsetDebutCode)) && ((memory+ptr->VM.offsetFinCode) > (memory+offset)))
			{  
				printf("\n Adresse invalide en Write");
				return 0;
			}				
	}		
	return 1;
}

void serializeInfoVM(char* buffer, struct infoVM* vm) {
    snprintf(buffer, 400, "VM %d: Busy=%d, TID=%d, MemoryStart=%p, CodeStart=%p, CodeEnd=%p",
             vm->noVM, vm->busy, vm->tid, 
             (void*)vm->ptrDebutVM, 
             (void*)vm->offsetDebutCode, 
             (void*)vm->offsetFinCode);
}


/* Read Image File */
int read_image_file(uint16_t * memory, char* image_path,uint16_t * origin,  struct noeudVM * ptr)
{
	 char fich[200];
	 strcpy(fich,image_path);
	 
	 if(fich[strlen(fich)-1]=='\r')
	 	fich[strlen(fich)-1]='\0';
  	 FILE* file = fopen(fich, "rb");
 
    if (!file) { return 0; }
    /* the origin tells us where in memory to place the image */
   	*origin=0x3000;

    /* we know the maximum file size so we only need one fread */
    uint16_t max_read = UINT16_MAX - *origin;
    uint16_t* p = memory + *origin;
    ptr->VM.offsetDebutCode = *origin;
    size_t read = fread(p, sizeof(uint16_t), max_read, file);
    ptr->VM.offsetFinCode = *origin+read-1;
    ptr->VM.DimRamUsed = read;// Ram utilisee par la VM 
    /* swap to little endian ???? */
    while (read-- > 0)
    {
    //	printf("\n p * BIG = %x",*p);
       // *p = swap16(*p);
		// printf("\n p * LITTLE = %x",*p);
        ++p;
    }
    return 1;
}


/* Check Key */
uint16_t check_key()
{
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO, &readfds);

    struct timeval timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
    return select(1, &readfds, NULL, NULL, &timeout) != 0;
}

/* Memory Access */
void mem_write(uint16_t * memory, uint16_t address, uint16_t val)
{
    memory[address] = val;
}

uint16_t mem_read( uint16_t * memory, uint16_t address)
{
    if (address == MR_KBSR)
    {
        if (check_key())
        {
            memory[MR_KBSR] = (1 << 15);
            memory[MR_KBDR] = getchar();
        }
        else
        {
            memory[MR_KBSR] = 0;
        }
    }
    return memory[address];
}

/* Input Buffering */
struct termios original_tio;

void disable_input_buffering()
{
    tcgetattr(STDIN_FILENO, &original_tio);
    struct termios new_tio = original_tio;
    new_tio.c_lflag &= ~ICANON & ~ECHO;
    tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);
}

void restore_input_buffering()
{
    tcsetattr(STDIN_FILENO, TCSANOW, &original_tio);
}

/* Handle Interrupt */
void handle_interrupt(int signal)
{
    restore_input_buffering();
    printf("\n");
    exit(-2);
}

// Function to check if the file exists and is executable
int is_executable(const char *filename) {
    struct stat file_stat;
    if (stat(filename, &file_stat) == 0) {
        return (file_stat.st_mode & S_IXUSR); // Check if the user has execute permissions
    }
    return 0;
}

// Function to execute a `.olc3` file
void executeFile(int client_socket, int priority, const char *filename) {
    char buffer[1024];

    // Validate file extension
    if (!strstr(filename, ".olc3")) {
        snprintf(buffer, sizeof(buffer), "Erreur : Le fichier %s n'est pas un fichier .olc3.\n", filename);
        send(client_socket, buffer, strlen(buffer), 0);
        return;
    }

    // Check if the file exists and is executable
    if (!is_executable(filename)) {
        snprintf(buffer, sizeof(buffer), "Erreur : Le fichier %s est introuvable ou non exécutable.\n", filename);
        send(client_socket, buffer, strlen(buffer), 0);
        return;
    }

    // Log the execution attempt
    snprintf(buffer, sizeof(buffer), "Exécution du fichier %s avec priorité %d...\n", filename, priority);
    send(client_socket, buffer, strlen(buffer), 0);

    // Execute the file (use system() or an exec function)
    int ret = system(filename);

    // Send the execution result to the client
    if (ret == -1) {
        snprintf(buffer, sizeof(buffer), "Erreur : Impossible d'exécuter le fichier %s.\n", filename);
    } else {
        snprintf(buffer, sizeof(buffer), "Le fichier %s a été exécuté avec succès.\n", filename);
    }
    send(client_socket, buffer, strlen(buffer), 0);
}

//#######################################
//# Recherche une VM dans la liste chaînée
//# ENTREE: Numéro de VM
//# RETOUR:	Un pointeur vers l'item recherché		
//# 		Retourne NULL dans le cas où l'item
//#			est introuvable
//#
struct noeudVM * findItem(const int no){
	//La liste est vide 
	if ((head==NULL)&&(queue==NULL)) return NULL;

	//Pointeur de navigation
	struct noeudVM * ptr = head;

	if(ptr->VM.noVM==no) // premier noeudVM
		return ptr;
	//Tant qu'un item suivant existe
	while (ptr->suivant!=NULL){

		//Déplacement du pointeur de navigation
		ptr=ptr->suivant;

		//Est-ce l'item recherché?
		if (ptr->VM.noVM==no){
			return ptr;
			}
		}
	//On retourne un pointeur NULL
	return NULL;
	}
//#######################################
//# Recherche une VM libre dans la liste chaînée
//# ENTREE: 
//# RETOUR:	Un pointeur vers la premiere VM libre	
//# 		Retourne NULL dans le cas où aucune VM disponible
struct noeudVM * findFreeVM(){
	//La liste VM est vide 
	if ((head==NULL)&&(queue==NULL)) return NULL;
	//Pointeur de navigation
	struct noeudVM * ptr = head;
	if(!ptr->VM.busy) // premier noeudVM voir si Not busy
		return ptr;
	while (ptr->suivant!=NULL){//Tant qu'un item suivant existe
		//Déplacement du pointeur de navigation
		ptr=ptr->suivant;
		//Est-ce l'item recherché?
		if (!ptr->VM.busy){
			return ptr;
			}
		}
	//On retourne un pointeur NULL aucune VM libre
	return NULL;
}
//#######################################
//#
//# Recherche le PRÉDÉCESSEUR d'un item dans la liste chaînée
//# ENTREE: Numéro de la ligne a supprimer
//# RETOUR:	Le pointeur vers le prédécesseur est retourné		
//# 		Retourne NULL dans le cas où l'item est introuvable
//#
struct noeudVM * findPrev(const int no){
	//La liste est vide 
	if ((head==NULL)&&(queue==NULL)) return NULL;
	//Pointeur de navigation
	struct noeudVM * ptr = head;
	//Tant qu'un item suivant existe
	while (ptr->suivant!=NULL){

		//Est-ce le prédécesseur de l'item recherché?
		if (ptr->suivant->VM.noVM==no){
			//On retourne un pointeur sur l'item précédent
			return ptr;
		}
		//Déplacement du pointeur de navigation
		ptr=ptr->suivant;
		}
	//On retourne un pointeur NULL
	return NULL;
	}

//#####################################################
//# Ajoute un noeud a la fin de la liste chaînée de VM
//# ENTREE: 
//#	RETOUR: ptr sur la VM ajoutee 
struct noeudVM* addItem(){
	//Création de l'enregistrement en mémoire
	struct noeudVM* ni = (struct noeudVM*)malloc(sizeof(struct noeudVM));
	//Affectation des valeurs des champs
	ni->VM.noVM	= ++nbVM;
	ni->VM.busy	= 0;
	ni->VM.DimRam	= 65536;
	ni->VM.DimRamUsed	= 0;
	ni->VM.tid	= gettid(); // # du process ou d'un thread
	ni->VM.ptrDebutVM	= (unsigned short*)malloc(sizeof(unsigned short)*65536);
	if ((head == NULL) && (queue == NULL)){//liste vide
	  ni->suivant= NULL;
	  queue = head = ni;
	  return ni;
	}
	struct noeudVM* tptr = queue;
	ni->suivant= NULL;
	queue = ni;	
	tptr->suivant = ni;
	return queue;
}

//#######################################
//# Retire un item de la liste chaînée
//# ENTREE: noVM: numéro du noeud a retirer 
void removeItem(const int noVM){
	struct noeudVM * ptr;
	struct noeudVM * tptr;
	struct noeudVM * optr;
	//Vérification sommaire (noVM>0 et liste non vide)	
	if ((noVM<1)||((head==NULL)&&(queue==NULL)))
		return;

	//Pointeur de recherche
	if(noVM==1){
		ptr = head; // suppression du premier element de la liste
	}
	else{
		ptr = findPrev(noVM);
	}
	//L'item a été trouvé
	if (ptr!=NULL){
		
		if(ptr->VM.busy) // ne pas supprimer une VM busy
		{
			return;
		}
		
		nbVM--;

		// Memorisation du pointeur de l'item en cours de suppression
		// Ajustement des pointeurs
		if((head == ptr) && (noVM==1)) // suppression de l'element de tete
		{
			if(head==queue) // un seul element dans la liste
			{
				free(ptr->VM.ptrDebutVM);
				free(ptr);
				queue = head = NULL;
				return;
			}
			tptr = ptr->suivant;
			head = tptr;
			free(ptr->VM.ptrDebutVM);
			free(ptr);
		}
		else if (queue==ptr->suivant) // suppression de l'element de queue
		{
			queue=ptr;
			free(ptr->suivant->VM.ptrDebutVM);
			free(ptr->suivant);
			ptr->suivant=NULL;
			return;
		}
		else // suppression d'un element dans la liste
		{
			optr = ptr->suivant;	
			ptr->suivant = ptr->suivant->suivant;
			tptr = ptr->suivant;
			free(optr->VM.ptrDebutVM);
			free(optr);
		}
		
		
		while (tptr!=NULL){ // ajustement des numeros de VM

		//Est-ce le prédécesseur de l'item recherché?
			tptr->VM.noVM--;
			//On retourne un pointeur sur l'item précédent	

		//Déplacement du pointeur de navigation
			tptr=tptr->suivant;
		}
	}
}

//#######################################
//#
//# Affiche les items dont le numéro séquentiel est compris dans une plage
//#
void listItems(int client_socket, int start, int end) {

    typedef struct VM {
    int id;
    char name[50];
    char status[20]; // "active", "inactive", etc.
    } VM;

    // Exemple d'une liste de VMs
    VM vm_list[] = {
        {1, "VM1", "active"},
        {2, "VM2", "inactive"},
        {3, "VM3", "active"},
        {4, "VM4", "active"},
        {5, "VM5", "inactive"},
        {6, "VM6", "active"}
    };

    int vm_list_size = sizeof(vm_list) / sizeof(VM);
    char buffer[1024];
    int found = 0;

    // Validation des plages
    if (start < 1 || end > vm_list_size || start > end) {
        snprintf(buffer, sizeof(buffer), "Erreur : Plage invalide [%d - %d].\n", start, end);
        send(client_socket, buffer, strlen(buffer), 0);
        return;
    }

    // Parcourir la liste des VMs dans la plage spécifiée
    for (int i = start - 1; i < end; i++) {
        snprintf(buffer, sizeof(buffer), "VM ID: %d, Name: %s, Status: %s\n",
                 vm_list[i].id, vm_list[i].name, vm_list[i].status);
        send(client_socket, buffer, strlen(buffer), 0);
        found = 1;
    }

    // Si aucune VM trouvée dans la plage
    if (!found) {
        snprintf(buffer, sizeof(buffer), "Aucune VM trouvée dans la plage [%d - %d].\n", start, end);
        send(client_socket, buffer, strlen(buffer), 0);
    } else {
        snprintf(buffer, sizeof(buffer), "Fin de la liste des VMs dans la plage [%d - %d].\n", start, end);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}
//#######################################
//#
void listOlcFile(int client_socket) {
    DIR *dir;
    struct dirent *entry;
    char buffer[1024];

    // Ouvrir le répertoire courant
    dir = opendir(".");
    if (dir == NULL) {
        snprintf(buffer, sizeof(buffer), "Erreur : Impossible d'ouvrir le répertoire courant.\n");
        send(client_socket, buffer, strlen(buffer), 0);
        return;
    }

    // Parcourir les fichiers du répertoire
    while ((entry = readdir(dir)) != NULL) {
        // Vérifier si l'extension est ".olc3"
        if (strstr(entry->d_name, ".olc3")) {
            snprintf(buffer, sizeof(buffer), "%s\n", entry->d_name);
            send(client_socket, buffer, strlen(buffer), 0); // Envoyer au client
        }
    }

    closedir(dir);

    // Indiquer la fin de la liste
    snprintf(buffer, sizeof(buffer), "Fin de la liste des fichiers .olc3\n");
    send(client_socket, buffer, strlen(buffer), 0);
}

//#######################################
//#
//# Afficher les info sur les process en execution (commande P)
//#
void processList(){
   char command[100];
	// listage des process
	sprintf(command, "ps -aux");
	system(command); // affichage sur le STDOUT 

}

typedef struct ThreadInfo {
    pthread_t tid;  // Thread ID
    int client_socket; // Associated client socket
} ThreadInfo;

// Example: Array to keep track of active threads (this would be dynamically managed in practice)
#define MAX_THREADS 100
ThreadInfo thread_list[MAX_THREADS];
int thread_count = 0;

void killThread(int client_socket, pthread_t tid_to_kill) {
    char buffer[1024];
    int found = 0;

    // Search for the thread in the thread list
    for (int i = 0; i < thread_count; i++) {
        if (pthread_equal(thread_list[i].tid, tid_to_kill)) {
            // Attempt to cancel the thread
            if (pthread_cancel(thread_list[i].tid) == 0) {
                snprintf(buffer, sizeof(buffer), "Thread %lu arrêté avec succès.\n", tid_to_kill);
                send(client_socket, buffer, strlen(buffer), 0);

                // Close the associated client socket if necessary
                if (thread_list[i].client_socket != -1) {
                    close(thread_list[i].client_socket);
                }

                // Remove the thread from the thread list
                thread_list[i] = thread_list[thread_count - 1];
                thread_count--;
                found = 1;
                break;
            } else {
                snprintf(buffer, sizeof(buffer), "Erreur : Impossible d'arrêter le thread %lu.\n", tid_to_kill);
                send(client_socket, buffer, strlen(buffer), 0);
                return;
            }
        }
    }

    // If the thread ID was not found
    if (!found) {
        snprintf(buffer, sizeof(buffer), "Erreur : Thread %lu introuvable.\n", tid_to_kill);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}


